/**
 * Inlined negotiator functionality
 * Based on negotiator (https://github.com/jshttp/negotiator)
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
function compareByQI(a, b) {
    return b.q - a.q || a.i - b.i || 0;
}
const simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptCharset(accept) {
    return accept.split(',').flatMap((s, i) => {
        const spec = parseCharset(s.trim(), i);
        return spec ? [spec] : [];
    });
}
function parseCharset(str, i) {
    const match = simpleCharsetRegExp.exec(str);
    if (!match)
        return null;
    const charset = match[1];
    const qParam = match[2]?.split(';').find((p) => p.trim().startsWith('q='));
    const q = qParam ? parseFloat(qParam.split('=')[1]) : 1;
    return { charset, q, i };
}
function getCharsetPriority(charset, accepted, index) {
    return accepted.reduce((priority, acc) => {
        const spec = specifyCharset(charset, acc, index);
        return spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0 ? spec : priority;
    }, { o: -1, q: 0, s: 0, i: index });
}
function specifyCharset(charset, spec, index) {
    let s = 0;
    if (spec.charset.toLowerCase() === charset.toLowerCase()) {
        s |= 1;
    }
    else if (spec.charset !== '*') {
        return null;
    }
    return { i: index, o: spec.i, q: spec.q, s };
}
function preferredCharsets(accept, provided) {
    const accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');
    if (!provided) {
        return accepts
            .filter(isQuality)
            .sort(compareByQI)
            .map((spec) => spec.charset);
    }
    const priorities = provided.map((type, index) => getCharsetPriority(type, accepts, index));
    return priorities
        .filter(isQuality)
        .sort(compareSpecs)
        .map((priority) => provided[priorities.indexOf(priority)]);
}
const simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptEncoding(accept) {
    const accepts = accept.split(',');
    const result = accepts.flatMap((s, i) => {
        const spec = parseEncoding(s.trim(), i);
        return spec ? [spec] : [];
    });
    const hasIdentity = result.some((enc) => specifyEncoding('identity', enc, 0) !== null);
    if (!hasIdentity) {
        const minQuality = result.reduce((min, enc) => Math.min(min, enc.q || 1), 1);
        result.push({ encoding: 'identity', q: minQuality, i: accepts.length });
    }
    return result;
}
function parseEncoding(str, i) {
    const match = simpleEncodingRegExp.exec(str);
    if (!match)
        return null;
    const encoding = match[1];
    const qParam = match[2]?.split(';').find((p) => p.trim().startsWith('q='));
    const q = qParam ? parseFloat(qParam.split('=')[1]) : 1;
    return { encoding, q, i };
}
function getEncodingPriority(encoding, accepted, index) {
    return accepted.reduce((priority, acc) => {
        const spec = specifyEncoding(encoding, acc, index);
        return spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0 ? spec : priority;
    }, { encoding, o: -1, q: 0, s: 0, i: index });
}
function specifyEncoding(encoding, spec, index) {
    let s = 0;
    if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s |= 1;
    }
    else if (spec.encoding !== '*') {
        return null;
    }
    return { encoding, i: index, o: spec.i, q: spec.q, s };
}
function preferredEncodings(accept, provided) {
    const accepts = parseAcceptEncoding(accept || '');
    if (!provided) {
        return accepts
            .filter(isQuality)
            .sort(compareByQI)
            .map((spec) => spec.encoding);
    }
    const priorities = provided.map((type, index) => getEncodingPriority(type, accepts, index));
    return priorities
        .filter(isQuality)
        .sort(compareSpecs)
        .map((priority) => provided[priorities.indexOf(priority)]);
}
const simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function parseAcceptLanguage(accept) {
    return accept.split(',').flatMap((s, i) => {
        const spec = parseLanguage(s.trim(), i);
        return spec ? [spec] : [];
    });
}
function parseLanguage(str, i) {
    const match = simpleLanguageRegExp.exec(str);
    if (!match)
        return null;
    const prefix = match[1];
    const suffix = match[2];
    const full = suffix ? `${prefix}-${suffix}` : prefix;
    const qParam = match[3]?.split(';').find((p) => p.startsWith('q='));
    const q = qParam ? parseFloat(qParam.split('=')[1]) : 1;
    return { prefix, suffix, q, i, full };
}
function getLanguagePriority(language, accepted, index) {
    return accepted.reduce((priority, acc) => {
        const spec = specifyLanguage(language, acc, index);
        return spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0 ? spec : priority;
    }, { o: -1, q: 0, s: 0, i: index });
}
function specifyLanguage(language, spec, index) {
    const p = parseLanguage(language, 0);
    if (!p)
        return null;
    let s = 0;
    if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
    }
    else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
    }
    else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
    }
    else if (spec.full !== '*') {
        return null;
    }
    return { i: index, o: spec.i, q: spec.q, s };
}
function preferredLanguages(accept, provided) {
    const accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');
    if (!provided) {
        return accepts
            .filter(isQuality)
            .sort(compareByQI)
            .map((spec) => spec.full);
    }
    const priorities = provided.map((type, index) => getLanguagePriority(type, accepts, index));
    return priorities
        .filter(isQuality)
        .sort(compareSpecs)
        .map((priority) => provided[priorities.indexOf(priority)]);
}
const simpleMediaTypeRegExp = /^\s*([^\s/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function parseAccept(accept) {
    return splitMediaTypes(accept).flatMap((s, i) => {
        const spec = parseMediaType(s.trim(), i);
        return spec ? [spec] : [];
    });
}
function parseMediaType(str, i) {
    const match = simpleMediaTypeRegExp.exec(str);
    if (!match)
        return null;
    const params = Object.create(null);
    let q = 1;
    const subtype = match[2];
    const type = match[1];
    if (match[3]) {
        const kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for (const pair of kvps) {
            const key = pair[0].toLowerCase();
            const val = pair[1];
            const value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.slice(1, -1) : val;
            if (key === 'q') {
                q = parseFloat(value);
                break;
            }
            params[key] = value;
        }
    }
    return { type, subtype, params, q, i };
}
function getMediaTypePriority(type, accepted, index) {
    return accepted.reduce((priority, acc) => {
        const spec = specifyMediaType(type, acc, index);
        return spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0 ? spec : priority;
    }, { o: -1, q: 0, s: 0, i: index });
}
function specifyMediaType(type, spec, index) {
    const p = parseMediaType(type, 0);
    if (!p)
        return null;
    let s = 0;
    if (spec.type.toLowerCase() === p.type.toLowerCase()) {
        s |= 4;
    }
    else if (spec.type !== '*') {
        return null;
    }
    if (spec.subtype.toLowerCase() === p.subtype.toLowerCase()) {
        s |= 2;
    }
    else if (spec.subtype !== '*') {
        return null;
    }
    const keys = Object.keys(spec.params);
    if (keys.length > 0) {
        if (keys.every((k) => spec.params[k] === '*' || (spec.params[k] || '').toLowerCase() === (p.params[k] || '').toLowerCase())) {
            s |= 1;
        }
        else {
            return null;
        }
    }
    return { i: index, o: spec.i, q: spec.q, s };
}
function preferredMediaTypes(accept, provided) {
    const accepts = parseAccept(accept === undefined ? '*/*' : accept || '');
    if (!provided) {
        return accepts
            .filter(isQuality)
            .sort(compareByQI)
            .map((spec) => `${spec.type}/${spec.subtype}`);
    }
    const priorities = provided.map((type, index) => getMediaTypePriority(type, accepts, index));
    return priorities
        .filter(isQuality)
        .sort(compareSpecs)
        .map((priority) => provided[priorities.indexOf(priority)]);
}
function quoteCount(str) {
    return (str.match(/"/g) || []).length;
}
function splitKeyValuePair(str) {
    const i = str.indexOf('=');
    return i === -1 ? [str, ''] : [str.slice(0, i), str.slice(i + 1)];
}
function splitMediaTypes(accept) {
    const accepts = accept.split(',');
    let j = 0;
    for (let i = 1; i < accepts.length; i++) {
        if (quoteCount(accepts[j]) % 2 === 0) {
            accepts[++j] = accepts[i];
        }
        else {
            accepts[j] += ',' + accepts[i];
        }
    }
    return accepts.slice(0, j + 1);
}
function splitParameters(str) {
    const parameters = str.split(';');
    let j = 0;
    for (let i = 1; i < parameters.length; i++) {
        if (quoteCount(parameters[j]) % 2 === 0) {
            parameters[++j] = parameters[i];
        }
        else {
            parameters[j] += ';' + parameters[i];
        }
    }
    return parameters.slice(0, j + 1).map((p) => p.trim());
}
// ============================================================================
// Shared utilities
// ============================================================================
function compareSpecs(a, b) {
    return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function isQuality(spec) {
    return spec.q > 0;
}
// ============================================================================
// Negotiator class
// ============================================================================
export class Negotiator {
    #request;
    constructor(request) {
        this.#request = request;
    }
    charsets(available) {
        const header = this.#request.headers['accept-charset'];
        const accept = Array.isArray(header) ? header.join(', ') : header;
        return preferredCharsets(accept, available);
    }
    encodings(available) {
        const header = this.#request.headers['accept-encoding'];
        const accept = Array.isArray(header) ? header.join(', ') : header;
        return preferredEncodings(accept, available);
    }
    languages(available) {
        const header = this.#request.headers['accept-language'];
        const accept = Array.isArray(header) ? header.join(', ') : header;
        return preferredLanguages(accept, available);
    }
    mediaTypes(available) {
        const header = this.#request.headers['accept'];
        const accept = Array.isArray(header) ? header.join(', ') : header;
        return preferredMediaTypes(accept, available);
    }
}
//# sourceMappingURL=negotiator.js.map